// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.20;

import {
    Order,
    FulfillmentComponent,
    Fulfillment,
    ItemType as SeaportItemType
} from "@seaport-types/lib/ConsiderationStructs.sol";
import {FallbackManager} from "@safe-contracts/base/FallbackManager.sol";

import {Errors} from "@src/libraries/Errors.sol";
import {
    OrderType,
    OrderMetadata,
    RentalOrder,
    Item,
    ItemType,
    SettleTo,
    Hook
} from "@src/libraries/RentalStructs.sol";

import {BaseTest} from "@test/BaseTest.sol";
import {ProtocolAccount} from "@test/utils/Types.sol";
import {SafeUtils} from "@test/utils/GnosisSafeUtils.sol";

import {SafeL2} from "@safe-contracts/SafeL2.sol";
import {PaymentEscrow} from "@src/modules/PaymentEscrow.sol";

contract Exploits is BaseTest {
    function test_DisableModule_Exploit() public {
        ///////////////////////////////////////////////////////////
        //                Admin whitelists a module              //
        ///////////////////////////////////////////////////////////

        // doesnt really matter what we enable as an extension,
        // so lets just use this address.
        vm.prank(deployer.addr);
        admin.toggleWhitelistExtension(address(this), true);

        ///////////////////////////////////////////////////////////
        //                  Enable the module tx                 //
        ///////////////////////////////////////////////////////////

        // create safe transaction to enable the module
        bytes memory transaction = abi.encodeWithSelector(
            0x610b5925,
            address(this) // whitelisted extension
        );

        // sign the safe transaction
        bytes memory transactionSignature = SafeUtils.signTransaction(
            address(alice.safe),
            alice.privateKey,
            address(alice.safe),
            transaction
        );

        // Expect the transaction to execute successfully
        SafeUtils.executeTransaction(
            address(alice.safe),
            address(alice.safe),
            transaction,
            transactionSignature
        );

        // assert the module has been enabled
        assertEq(alice.safe.isModuleEnabled(address(this)), true);

        // asser the stop policy is still enabled
        assertEq(alice.safe.isModuleEnabled(address(stop)), true);

        ///////////////////////////////////////////////////////////
        //           Attempt to disable the module tx            //
        ///////////////////////////////////////////////////////////

        // create safe transaction to disable the stop policy
        bytes memory transactionToDisable = abi.encodeWithSelector(
            0xe009cfde,
            address(this), // whitelisted extension -> prev module
            address(stop) // module
        );

        // sign the safe transaction
        bytes memory transactionSignatureToDisable = SafeUtils.signTransaction(
            address(alice.safe),
            alice.privateKey,
            address(alice.safe),
            transactionToDisable
        );

        // Expect the transaction to revert
        SafeUtils.executeTransactionWithError(
            address(alice.safe),
            address(alice.safe),
            transactionToDisable,
            transactionSignatureToDisable,
            abi.encodeWithSelector(
                Errors.GuardPolicy_UnauthorizedExtension.selector,
                address(stop)
            )
        );

        // Assert the stop policy is still enabled
        assertEq(alice.safe.isModuleEnabled(address(stop)), true);
    }

    // Demonstrates that the owner of a safe can no longer set a custom fallback manager
    // on their safe.
    function test_SetFallbackHandler_Exploit() public {
        // Impersonate the attacker
        vm.startPrank(alice.addr);

        // create the `setFallbackHandler` calldata
        bytes memory setFallbackHandlerCalldata = abi.encodeWithSelector(
            FallbackManager.setFallbackHandler.selector,
            address(this) // use address this as an example
        );

        // Sign the calldata
        bytes memory transactionSignature = SafeUtils.signTransaction(
            address(alice.safe),
            alice.privateKey,
            address(alice.safe),
            setFallbackHandlerCalldata
        );

        // Expect the transaction to revert
        SafeUtils.executeTransactionWithError(
            address(alice.safe),
            address(alice.safe),
            setFallbackHandlerCalldata,
            transactionSignature,
            abi.encodeWithSelector(
                Errors.GuardPolicy_UnauthorizedSelector.selector,
                FallbackManager.setFallbackHandler.selector
            )
        );
    }
}
