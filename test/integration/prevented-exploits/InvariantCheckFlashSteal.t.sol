// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.20;

import {IERC721Errors} from "@openzeppelin-contracts/interfaces/draft-IERC6093.sol";
import {ECDSA} from "@openzeppelin-contracts/utils/cryptography/ECDSA.sol";
import {
    Order,
    FulfillmentComponent,
    Fulfillment,
    ItemType as SeaportItemType,
    CriteriaResolver,
    AdvancedOrder,
    OfferItem,
    ConsiderationItem,
    OrderComponents,
    OrderType as SeaportOrderType,
    ItemType
} from "@seaport-types/lib/ConsiderationStructs.sol";
import {ZoneParameters} from "@seaport-core/lib/rental/ConsiderationStructs.sol";
import {
    OfferItemLib,
    OrderComponentsLib,
    ConsiderationItemLib,
    OrderLib
} from "@seaport-sol/SeaportSol.sol";
import {Enum} from "@safe-contracts/common/Enum.sol";

import {ZoneInterface} from "@src/interfaces/IZone.sol";
import {ISafe} from "@src/interfaces/ISafe.sol";
import {OrderType, OrderMetadata, RentalOrder} from "@src/libraries/RentalStructs.sol";
import {Errors} from "@src/libraries/Errors.sol";

import {BaseTest} from "@test/BaseTest.sol";
import {SafeUtils} from "@test/utils/GnosisSafeUtils.sol";
import {ProtocolAccount} from "@test/utils/Types.sol";

// Demonstrates that the invariant checks cannot be bypassed because creation of a rental
// will fail if it detects that an offerer of an order will also be the recipient of any
// consideration items in that order. This prevents a malicious actor from creating a
// PAYEE order which contains consideration items that have the offerer as the recipient.
//
// This is important because seaport treats offerer == considerationItem.recipient as a
// no-op, and will not transfer the tokens nor will it make an entry in the
// totalExecutions array.
//
// The result of this is that an order could be considered valid by the protocol which
// did not transfer any tokens to the protocol.

// When combined with 2 other orders, one that uses a seaport zone to execute
// transactions on the offerer's safe, and a legit order that actually does transfer
// the tokens, it results in a situation where the offerer of the malicious order can
// stop their rental and receive tokens that they did not originally send to the
// protocol. Of course, they will eventually have to give these tokens back to allow the
// legit order to process.
//
// Once the first malicious order (which mimics the items in the legit order) is
// processed and started, the second order is executed which uses a zone that stops the
// first malicious order which will send the tokens to the offerer. This offerer was not
// the original owner of the assets. The zone contract can then execute pre-signed gnosis
// safe transactions to use the assets. When execution flow completes on the zone, it
// will need to return the tokens to the Create policy so that the legit order can
// process as expected.
contract InvariantCheckFlashSteal_PreventedExploits_Integration_Test is BaseTest {
    using OfferItemLib for OfferItem;
    using ConsiderationItemLib for ConsiderationItem;
    using OrderComponentsLib for OrderComponents;
    using OrderLib for Order;
    using ECDSA for bytes32;

    // Tokens to flash steal
    address public ERC721TokenToFlashSteal;
    address public ERC20TokenToReturnToCreatePolicyAfterTheft;

    // Malicious zone contract
    MaliciousZone public maliciousZone;

    // Perform the test to show the mitigation
    function test_InvariantCheckFlashSteal_Exploit() public {
        // This will be the token that a flash steal will be attempted on. In other
        // words, it will be the token Alice (the victim lender), will be lending to
        // bob, the attacker.
        ERC721TokenToFlashSteal = address(erc721s[0]);

        // Alice will be rewarding bob with erc20 for the PAY order so those also will
        // be flash stolen (although flash stealing erc20 is useless)
        ERC20TokenToReturnToCreatePolicyAfterTheft = address(erc20s[0]);

        // Deploy the malicious zone contract
        maliciousZone = new MaliciousZone(address(bob.safe), address(stop));

        // Construct the malicious PAY order, where bob's rental safe will be lending to
        // itself. The recipient will be the same as the offerer, so that
        // `executionInvariantChecks` will be bypassed. The offer item will be set to the
        // same NFT as the ones Alice will be lending Bob (aka, the NFT we will be
        // hijacking). This order will be executed first.
        constructMaliciousPAYOrder();

        // This is just a useless intermediary order just so that we get to execute a
        // malicious zone contract of ours between the execution of the malicious pay
        // order and the legitimate. So with this order, we're just hijacking the
        // execution flow.
        constructMaliciousZoneOrder();

        // This is the legitimate PAY order, where Alice will be lending Bob (attacker),
        // an NFT and ERC20 which will both be flash stolen.
        constructLegitimatePAYOrder();

        // Construct the expected output of the malicious rental order so that it can be
        // stopped later
        RentalOrder memory maliciousRentalOrder = _createRentalOrder(ordersToFulfill[0]);

        // Prepare the pre-signed transactions which will attempt to stop the malicious
        // rental order.
        preparePreSignedTXs(maliciousRentalOrder);

        // Execute all the orders, but expect to revert since an order cannot be stopped
        // in the same transaction that it was created.
        finalizePayOrdersFulfillmentWithError("GS013");
    }

    // Construct the malicious PAY order. This will mimic the legit PAY order.
    function constructMaliciousPAYOrder() public {
        // Cache bob's original EOA address.
        address bobsOriginalEOA_Address = bob.addr;

        // We're making this fixture because we want bob's rental safe to be
        // the lender (smart contract), not bob himself (EOA).
        bob.addr = address(bob.safe);

        // create a legit PAY order
        createOrder({
            offerer: bob,
            orderType: OrderType.PAY,
            erc721Offers: 1,
            erc1155Offers: 0,
            erc20Offers: 1,
            erc721Considerations: 0,
            erc1155Considerations: 0,
            erc20Considerations: 0
        });

        // Reset the value back.
        bob.addr = bobsOriginalEOA_Address;

        // Remove pre-inserted offer items
        popOfferItem();
        popOfferItem();

        // Add custom offer items
        withOfferItem(
            OfferItemLib
                .empty()
                .withItemType(ItemType.ERC721)
                .withToken(address(ERC721TokenToFlashSteal))
                .withIdentifierOrCriteria(1)
                .withStartAmount(1)
                .withEndAmount(1)
        );
        withOfferItem(
            OfferItemLib
                .empty()
                .withItemType(ItemType.ERC20)
                .withToken(address(erc20s[0]))
                .withIdentifierOrCriteria(0)
                .withStartAmount(100)
                .withEndAmount(100)
        );

        // create and sign the order. Since the offerer is a rental safe, we will need
        // to create a EIP-1271 signature
        (
            Order memory payOrder,
            bytes32 payOrderHash
        ) = _signSeaportOrderForGnosisSafeBeingALender(
                orderToCreate.offerer,
                orderToCreate.offerItems,
                orderToCreate.considerationItems,
                orderToCreate.metadata
            );

        // pull order metadata into memory
        OrderMetadata memory payOrderMetadata = orderToCreate.metadata;

        // clear structs
        resetOrderToCreate();

        // create an order fulfillment for the pay order
        createOrderFulfillment({
            _fulfiller: bob,
            order: payOrder,
            orderHash: payOrderHash,
            metadata: payOrderMetadata
        });

        // create a malicious PAYEE order.
        createOrder({
            offerer: bob,
            orderType: OrderType.PAYEE,
            erc721Offers: 0,
            erc1155Offers: 0,
            erc20Offers: 0,
            erc721Considerations: 1,
            erc1155Considerations: 0,
            erc20Considerations: 1
        });

        // We will remove the pre-inserted consideration items because the recipients
        // are set to the Create policy, and we want them to be set to
        // bob (the attacker), so that the offerer == recipient and
        // `executionInvariantChecks` are bypassed.
        popConsiderationItem();
        popConsiderationItem();

        // Set the recipient to be the same as the offerer
        withConsiderationItem(
            ConsiderationItemLib
                .empty()
                .withItemType(ItemType.ERC721)
                .withToken(address(ERC721TokenToFlashSteal))
                .withIdentifierOrCriteria(1)
                .withStartAmount(1)
                .withEndAmount(1)
                .withRecipient(address(bob.safe))
        );
        withConsiderationItem(
            ConsiderationItemLib
                .empty()
                .withItemType(ItemType.ERC20)
                .withToken(address(erc20s[0]))
                .withIdentifierOrCriteria(0)
                .withStartAmount(100)
                .withEndAmount(100)
                .withRecipient(address(bob.safe))
        );

        // finalize the pay order creation
        (
            Order memory payeeOrder,
            bytes32 payeeOrderHash,
            OrderMetadata memory payeeOrderMetadata
        ) = finalizeOrder();

        // create an order fulfillment for the payee order
        createOrderFulfillment({
            _fulfiller: bob,
            order: payeeOrder,
            orderHash: payeeOrderHash,
            metadata: payeeOrderMetadata
        });

        // Link the PAY and PAYEE orders
        withLinkedPayAndPayeeOrders({payOrderIndex: 0, payeeOrderIndex: 1});
    }

    // Construct the malicious zone order. It's a useless order, we're just making it
    // because it'll allow us to execute a zone of our choice and hijack
    // the execution flow.
    function constructMaliciousZoneOrder() public {
        OrderComponentsLib
            .empty()
            .withOrderType(SeaportOrderType.FULL_RESTRICTED)
            .withZone(address(maliciousZone))
            .withStartTime(block.timestamp)
            .withEndTime(block.timestamp + 500)
            .withSalt(10291312143)
            .withConduitKey(conduitKey)
            .saveDefault("malicious");

        orderToCreate.offerer = bob;

        orderToCreate.metadata.orderType = OrderType.BASE;
        orderToCreate.metadata.rentDuration = 300;
        orderToCreate.metadata.emittedExtraData = new bytes(0);

        // build up order components
        OrderComponents memory orderComponents = OrderComponentsLib
            .fromDefault("malicious")
            .withOfferer(bob.addr)
            .withCounter(seaport.getCounter(bob.addr));

        // generate order hash from the order components
        bytes32 exploitOrderHash = seaport.getOrderHash(orderComponents);

        // fetch domain separator from seaport
        (, bytes32 domainSeparator, ) = seaport.information();

        // sign the EIP-712 digest
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(
            bob.privateKey,
            domainSeparator.toTypedDataHash(exploitOrderHash)
        );

        // encode the signature
        bytes memory signature = abi.encodePacked(r, s, v);

        // Create the order
        Order memory exploitOrder = OrderLib
            .empty()
            .withParameters(orderComponents.toOrderParameters())
            .withSignature(signature);

        // create an order fulfillment
        createOrderFulfillment({
            _fulfiller: bob,
            order: exploitOrder,
            orderHash: exploitOrderHash,
            metadata: orderToCreate.metadata
        });
    }

    // Construct the legitimate PAY order
    function constructLegitimatePAYOrder() public {
        // create a PAY order
        createOrder({
            offerer: alice,
            orderType: OrderType.PAY,
            erc721Offers: 1,
            erc1155Offers: 0,
            erc20Offers: 1,
            erc721Considerations: 0,
            erc1155Considerations: 0,
            erc20Considerations: 0
        });

        // finalize the pay order creation
        (
            Order memory payOrder,
            bytes32 payOrderHash,
            OrderMetadata memory payOrderMetadata
        ) = finalizeOrder();

        // create a PAYEE order. The fulfiller will be the offerer.
        createOrder({
            offerer: bob,
            orderType: OrderType.PAYEE,
            erc721Offers: 0,
            erc1155Offers: 0,
            erc20Offers: 0,
            erc721Considerations: 1,
            erc1155Considerations: 0,
            erc20Considerations: 1
        });

        // finalize the pay order creation
        (
            Order memory payeeOrder,
            bytes32 payeeOrderHash,
            OrderMetadata memory payeeOrderMetadata
        ) = finalizeOrder();

        // create an order fulfillment for the pay order
        createOrderFulfillment({
            _fulfiller: bob,
            order: payOrder,
            orderHash: payOrderHash,
            metadata: payOrderMetadata
        });

        // create an order fulfillment for the payee order
        createOrderFulfillment({
            _fulfiller: bob,
            order: payeeOrder,
            orderHash: payeeOrderHash,
            metadata: payeeOrderMetadata
        });

        withLinkedPayAndPayeeOrders({payOrderIndex: 3, payeeOrderIndex: 4});
    }

    // Prepares signed transactions for the malicious zone to execute on behalf of the
    // gnosis safe.
    function preparePreSignedTXs(RentalOrder memory maliciousRentalOrder) public {
        // calldata to stop the rental once we arrive at the malicious zone
        bytes memory transaction = abi.encodeWithSelector(
            stop.stopRent.selector,
            maliciousRentalOrder
        );

        // Sign the gnosis safe transaction
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(
            bob.privateKey,
            ISafe(address(bob.safe)).getTransactionHash(
                address(stop),
                0 ether,
                transaction,
                Enum.Operation.Call,
                0 ether,
                0 ether,
                0 ether,
                address(0),
                payable(address(0)),
                ISafe(address(bob.safe)).nonce()
            )
        );

        // Signature of the TX of rental stopping.
        bytes memory transactionSignature = abi.encodePacked(r, s, v);

        // Setting those values on the malicious zone contract
        maliciousZone.setStopRentTXSignature(transactionSignature);
        maliciousZone.setStopRentTXCalldata(transaction);
    }

    // Creates a signed seaport order which has been wrapped in a gnosis safe message
    // which makes it compatible to be executed using eip-1271
    function _signSeaportOrderForGnosisSafeBeingALender(
        ProtocolAccount memory _offerer,
        OfferItem[] memory _offerItems,
        ConsiderationItem[] memory _considerationItems,
        OrderMetadata memory _metadata
    ) private view returns (Order memory order, bytes32 orderHash) {
        // put offerer address on stack
        address offerer = _offerer.addr;

        // Build the order components
        OrderComponents memory orderComponents = OrderComponentsLib
            .fromDefault(STANDARD_ORDER_COMPONENTS)
            .withOfferer(offerer)
            .withOffer(_offerItems)
            .withConsideration(_considerationItems)
            .withZoneHash(create.getOrderMetadataHash(_metadata))
            .withCounter(seaport.getCounter(offerer));

        // generate the order hash
        orderHash = seaport.getOrderHash(orderComponents);

        // fetch domain separator from seaport
        (, bytes32 domainSeparator, ) = seaport.information();

        // Create a message hash using the fallback policy. This will prep the digest
        // to be eip-1271 compatible for the gnosis safe.
        bytes32 messageHash = fallbackPolicy.getMessageHashForSafe(
            bob.safe,
            abi.encodePacked(domainSeparator.toTypedDataHash(orderHash))
        );

        // sign the EIP-712 digest
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(_offerer.privateKey, messageHash);

        // encode the signature
        bytes memory signature = abi.encodePacked(r, s, v);

        // create the order, but dont provide a signature if its a PAYEE order.
        // Since PAYEE orders are fulfilled by the offerer of the order, they
        // dont need a signature.
        if (_metadata.orderType == OrderType.PAYEE) {
            order = OrderLib.empty().withParameters(orderComponents.toOrderParameters());
        } else {
            order = OrderLib
                .empty()
                .withParameters(orderComponents.toOrderParameters())
                .withSignature(signature);
        }
    }
}

contract MaliciousZone {
    address private owner; // address of the attacker (bob.addr)
    address private attackersSafe; // address of the attacker's rental safe (bob.safe)
    address private stopPolicy; // the address of the ReNFT stop policy

    bytes private stopRentTXCalldata; // calldata of the stopRent() TX which will be made
    bytes private stopRentTXSignature; // Signature of the stopRent() TX which will be made

    constructor(address _attackersSafe, address _stopPolicy) {
        attackersSafe = _attackersSafe;
        stopPolicy = _stopPolicy;
        owner = msg.sender;
    }

    // A setter function to set the signature for a TX where the malicious self-rental
    // will be stopped
    function setStopRentTXSignature(bytes memory _signature) external onlyOwner {
        stopRentTXSignature = _signature;
    }

    // A setter function to set the calldata for a TX where the malicious self-rental
    // will be stopped
    function setStopRentTXCalldata(bytes memory _stopRentTXCalldata) external onlyOwner {
        stopRentTXCalldata = _stopRentTXCalldata;
    }

    function validateOrder(
        ZoneParameters calldata
    ) external returns (bytes4 validOrderMagicValue) {
        // Stop the malicious order rental. NOTE: this will fail because orders cannot
        // be stopped in the same transaction that they were created in.
        SafeUtils.executeTransaction(
            address(attackersSafe),
            address(stopPolicy),
            stopRentTXCalldata,
            stopRentTXSignature
        );

        // Return the selector of validateOrder as the magic value.
        validOrderMagicValue = ZoneInterface.validateOrder.selector;
    }

    modifier onlyOwner() {
        require(owner == msg.sender);
        _;
    }
}
