// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.20;

import {IERC721Errors} from "@openzeppelin-contracts/interfaces/draft-IERC6093.sol";
import {IERC1155} from "@openzeppelin-contracts/interfaces/IERC1155.sol";
import {
    ItemType,
    Order,
    OfferItem,
    AdvancedOrder,
    FulfillmentComponent,
    CriteriaResolver
} from "@seaport-types/lib/ConsiderationStructs.sol";
import {ZoneParameters} from "@seaport-core/lib/rental/ConsiderationStructs.sol";
import {OfferItemLib} from "@seaport-sol/SeaportSol.sol";

import {ZoneInterface} from "@src/interfaces/IZone.sol";
import {OrderType, OrderMetadata, RentalOrder} from "@src/libraries/RentalStructs.sol";
import {Errors} from "@src/libraries/Errors.sol";

import {BaseTest} from "@test/BaseTest.sol";
import {SafeUtils} from "@test/utils/GnosisSafeUtils.sol";
import {MockERC1155} from "@test/mocks/tokens/standard/MockERC1155.sol";
import {MockERC721} from "@test/mocks/tokens/standard/MockERC721.sol";

// Demonstrates that stopping a rental can no longer be re-entered which would have
// led to a loss of ERC1155 funds.
contract StopRentReentrancy_PreventedExploits_Integration_Test is BaseTest {
    using OfferItemLib for OfferItem;

    // Malicious lender contract
    MaliciousLender maliciousLenderContract;

    function test_StopRentReentrancy_Exploit() public {
        // bob    ==  attacker (borrower), also the owner of the malicious lender contract.
        // alice  ==  victim (lender)

        ///////////////////////////////////////////////////////////
        //            Deployment of essential contracts          //
        ///////////////////////////////////////////////////////////

        // Deploy the malicious lender contract. Bob will be the owner of the malicious
        // lender contract
        vm.prank(bob.addr);
        maliciousLenderContract = new MaliciousLender();

        // A test ERC1155 token
        MockERC1155 testERC1155Token = new MockERC1155();

        // A test ERC721 token
        MockERC721 testERC721Token = new MockERC721();

        ///////////////////////////////////////////////////////////
        //               Approvals & asset whitelist             //
        ///////////////////////////////////////////////////////////

        // Add the test ERC721/1155 to the whitelist
        vm.startPrank(deployer.addr);
        admin.toggleWhitelistAsset(address(testERC1155Token), uint8(3));
        admin.toggleWhitelistAsset(address(testERC721Token), uint8(3));
        vm.stopPrank();

        // We will give alice (lender) 100 ERC1155 tokens to lend, and approve conduit
        testERC1155Token.mint(address(alice.addr), 1, 100);

        // We will give the malicious lender contract (bob) 100 ERC1155 tokens
        // for the malicious rental
        testERC1155Token.mint(address(maliciousLenderContract), 1, 100);

        // We will give the malicious lender contract (bob) a dummy ERC721 token for the
        // malicious rental
        testERC721Token.mint(address(maliciousLenderContract), 1);

        // Approve the conduit to spend alice's tokens
        vm.prank(address(alice.addr));
        testERC1155Token.setApprovalForAll(address(conduit), true);

        // Approve the conduit to spend bob's tokens
        vm.startPrank(address(maliciousLenderContract));
        testERC1155Token.setApprovalForAll(address(conduit), true);
        testERC721Token.setApprovalForAll(address(conduit), true);
        vm.stopPrank();

        ///////////////////////////////////////////////////////////
        //          Setting up the legitimate rental order       //
        ///////////////////////////////////////////////////////////

        // We'll simulate a rental order where the attacker rents 100 ERC1155 tokens from Alice
        // Lender (victim)      ==   Alice
        // Borrower (attacker)  ==   Bob
        (, bytes32 legitimateRentalOrderHash, ) = setupLegitimateRental(
            address(testERC1155Token)
        );

        // assert that the rental order was stored
        assertEq(STORE.orders(legitimateRentalOrderHash), true);

        // assert that 100 ERC1155 tokens exist in the borrower's safe (in this case, it's the attacker's safe)
        assertEq(STORE.isRentedOut(address(bob.safe), address(testERC1155Token), 1), 100);

        // assert that 100 ERC1155 tokens are in the rental wallet of the fulfiller
        assertEq(testERC1155Token.balanceOf(address(bob.safe), 1), 100);

        ///////////////////////////////////////////////////////////
        //               Setting up the malicious order          //
        ///////////////////////////////////////////////////////////

        // The malicious rental is basically a self-rent. The lender is a smart contract
        // made by the attacker and the borrower is the attacker's reNFT rental safe

        // Impersonate the attacker (owner of the malicious lender contract).
        vm.startPrank(bob.addr);

        // Set the attacker's (bob) safe address on the malicious lender contract which the malicious lender contract will communicate with.
        maliciousLenderContract.setSafeAddr(address(bob.safe));

        // Set the address of the token which the attacker wants to hijack on the malicious lender contract.
        maliciousLenderContract.setTokenToHijackAddr(address(testERC1155Token));

        vm.stopPrank();

        // Setup the malicious rental.
        // Lender    ==   the malicious lender contract (owned by bob, the attacker)
        // Borrower  ==   the attacker's rental safe (bob)
        (
            RentalOrder memory maliciousRentalOrder,
            bytes32 maliciousRentalOrderHash,

        ) = setupMaliciousRental(address(testERC1155Token));

        // assert that the rental order was stored
        assertEq(STORE.orders(maliciousRentalOrderHash), true);

        // assert that 200 ERC1155 tokens exist in the borrower's safe (in this case, it's the attacker's safe)
        assertEq(STORE.isRentedOut(address(bob.safe), address(testERC1155Token), 1), 200);

        // assert that the ERC1155 is in the rental wallet of the fulfiller (attacker)
        assertEq(testERC1155Token.balanceOf(address(bob.safe), 1), 200);

        ///////////////////////////////////////////////////////////
        //                Setting up the exploit                 //
        ///////////////////////////////////////////////////////////

        // Prepare the pre-signed `transferFrom` malicious TX which the malicious
        // lender will execute upon `onERC1155Received` callback function execution

        // The malicious TX which the malicious lender contract will execute when `onERC721Received` callback function is executed in it.
        bytes memory hijackTX = abi.encodeWithSignature(
            "safeTransferFrom(address,address,uint256,uint256,bytes)",
            address(bob.safe),
            address(bob.addr),
            1,
            99,
            ""
        );

        // Get the signature of the malicious TX.
        bytes memory transactionSignature = SafeUtils.signTransaction(
            address(bob.safe),
            bob.privateKey,
            address(testERC1155Token),
            hijackTX
        );

        // Set the malicious TX and it's signature on the malicious lender contract so that it sends it
        vm.prank(bob.addr);
        maliciousLenderContract.setSignatureAndTransaction(
            transactionSignature,
            hijackTX
        );

        // speed up in time past the rental expiration
        // Attacker can just construct a PAY order and terminate the rental at any time
        vm.warp(block.timestamp + 1000000);

        // Stop the malicious rental order
        vm.prank(address(maliciousLenderContract));
        vm.expectRevert(abi.encodeWithSelector(Errors.StopPolicy_ReclaimFailed.selector));
        stop.stopRent(maliciousRentalOrder);

        ///////////////////////////////////////////////////////////
        //                 Proof of mitigation                   //
        ///////////////////////////////////////////////////////////

        // At this point, the `stopRent` transaction has failed. Looking throught the
        // execution call stack, you can see that the original revert occurs within
        // `onERC1155Received` when calling `execTransaction`.
        //
        // The error returned from the reverted call is:
        // 		GuardPolicy_UnauthorizedAssetAmount(
        //      	0xf242432a00000000000000000000000000000000000000000000000000000000,
        //			200,
        // 			100
        // 		)
        //
        // This error shows that the malicious contract was unable to pull extra funds
        // out of the safe because the rental is still considered active.

        // Assert that none of the tokens are held by bob's EOA, and all the tokens
        // are still held in bob's rental safe
        assertEq(testERC1155Token.balanceOf(address(bob.addr), 1), 0);
        assertEq(testERC1155Token.balanceOf(address(bob.safe), 1), 200);
    }

    function setupLegitimateRental(
        address test_ERC1155_Token
    ) public returns (RentalOrder memory, bytes32, OrderMetadata memory) {
        // create a BASE order
        createOrder({
            offerer: alice,
            orderType: OrderType.BASE,
            erc721Offers: 0,
            erc1155Offers: 1,
            erc20Offers: 0,
            erc721Considerations: 0,
            erc1155Considerations: 0,
            erc20Considerations: 1
        });

        // Remove the pre-inserted offer item (which is inserted by the tests)
        popOfferItem();

        // Set the test ERC1155 token which we created as the offer item
        withOfferItem(
            OfferItemLib
                .empty()
                .withItemType(ItemType.ERC1155)
                .withToken(address(test_ERC1155_Token))
                .withIdentifierOrCriteria(1)
                .withStartAmount(100)
                .withEndAmount(100)
        );

        // Finalize the order creation
        (
            Order memory order,
            bytes32 orderHash,
            OrderMetadata memory metadata
        ) = finalizeOrder();

        // Create an order fulfillment
        createOrderFulfillment({
            _fulfiller: bob,
            order: order,
            orderHash: orderHash,
            metadata: metadata
        });

        // Finalize the base order fulfillment
        RentalOrder memory rentalOrder = finalizeBaseOrderFulfillment();

        // get the rental order hash
        bytes32 rentalOrderHash = create.getRentalOrderHash(rentalOrder);

        return (rentalOrder, rentalOrderHash, metadata);
    }

    function setupMaliciousRental(
        address test_ERC1155_Token
    ) public returns (RentalOrder memory, bytes32, OrderMetadata memory) {
        // Cache bob's EOA address
        address bobsOriginalEOA_Address = bob.addr;

        // We're doing this because we're passing bob's `ProtocolAccount` struct to `createOrder()`
        // And we're doing so because we want to simulate the lender (bob) being a smart contract, not an EOA
        bob.addr = address(maliciousLenderContract);

        // create a BASE order
        createOrder({
            offerer: bob,
            orderType: OrderType.BASE,
            erc721Offers: 0,
            erc1155Offers: 2, // We'll lend ourselves 2 erc1155 tokens of the same kind & ID
            erc20Offers: 0,
            erc721Considerations: 0,
            erc1155Considerations: 0,
            erc20Considerations: 1
        });

        // Restore the correct address of the ProtocolAccount `bob` struct.
        bob.addr = bobsOriginalEOA_Address;

        // Remove the two pre-inserted offer items (which are inserted by the tests)
        popOfferItem();
        popOfferItem();

        // Lend ourselves 1 ERC1155 token.
        withOfferItem(
            OfferItemLib
                .empty()
                .withItemType(ItemType.ERC1155)
                .withToken(address(test_ERC1155_Token))
                .withIdentifierOrCriteria(1)
                .withStartAmount(1)
                .withEndAmount(1)
        );

        // Lend ourselves 99 ERC1155 tokens on top of the 1 token.
        withOfferItem(
            OfferItemLib
                .empty()
                .withItemType(ItemType.ERC1155)
                .withToken(address(test_ERC1155_Token))
                .withIdentifierOrCriteria(1)
                .withStartAmount(99)
                .withEndAmount(99)
        );

        // Finalize the order creation
        (
            Order memory order,
            bytes32 orderHash,
            OrderMetadata memory metadata
        ) = finalizeOrder();

        // Create an order fulfillment
        createOrderFulfillment({
            _fulfiller: bob,
            order: order,
            orderHash: orderHash,
            metadata: metadata
        });

        // Finalize the base order fulfillment
        RentalOrder memory rentalOrder = finalizeBaseOrderFulfillment();

        // get the rental order hash
        bytes32 rentalOrderHash = create.getRentalOrderHash(rentalOrder);

        return (rentalOrder, rentalOrderHash, metadata);
    }
}

///////////////////////////////////////////////////////////
//                Malicious lender contract              //
///////////////////////////////////////////////////////////

contract MaliciousLender {
    address private owner; // owner of the contract
    address private safe; // The address of the attacker's safe.
    address private tokenToHijack; // The address of the ERC1155 token which the attacker wants to hijack.

    bytes maliciousSafeTransactionSignature; // Signature needed for the Safe TX.
    bytes maliciousSafeTransaction; // The transaction sent to the attacker's safe which will hijack the token

    bool private lock;

    constructor() {
        owner = msg.sender;
    }

    function setSafeAddr(address _safe) external onlyOwner {
        safe = _safe;
    }

    function setTokenToHijackAddr(address _tokenAddr) external onlyOwner {
        tokenToHijack = _tokenAddr;
    }

    function setSignatureAndTransaction(
        bytes memory _signature,
        bytes memory _transaction
    ) external onlyOwner {
        maliciousSafeTransactionSignature = _signature;
        maliciousSafeTransaction = _transaction;
    }

    function onERC721Received(
        address,
        address,
        uint256,
        bytes memory
    ) public virtual returns (bytes4) {
        return this.onERC721Received.selector;
    }

    function onERC1155Received(
        address,
        address from,
        uint256 id,
        uint256,
        bytes memory
    ) public virtual returns (bytes4) {
        // If == address(0), we don't want to trigger `_hijackERC1155Tokens`, because it'd be a mint in this case, not an actual transfer.
        if (from != address(0)) {
            // Redirect any ERC1155 tokens transferred to this contract to the owner of it (Bob)
            IERC1155(msg.sender).safeTransferFrom(
                address(this),
                owner,
                id,
                IERC1155(msg.sender).balanceOf(address(this), id),
                ""
            );

            // On top of the previous condition, check if the variable `lock` is set to false, if yes execute the TX and set `lock` to true
            // We are doing the `lock` variable check because we only want `_hijackERC1155Tokens` to be executed once.
            if (lock == false) {
                _hijackERC1155Tokens();
                lock = true;
            }
        }

        return this.onERC1155Received.selector;
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] memory,
        uint256[] memory,
        bytes memory
    ) public virtual returns (bytes4) {
        return this.onERC1155BatchReceived.selector;
    }

    // A helper function to split the signature
    function splitSignature(
        bytes memory sig
    ) public pure returns (uint8 v, bytes32 r, bytes32 s) {
        require(sig.length == 65);

        assembly {
            // first 32 bytes, after the length prefix.
            r := mload(add(sig, 32))
            // second 32 bytes.
            s := mload(add(sig, 64))
            // final byte (first byte of the next 32 bytes).
            v := byte(0, mload(add(sig, 96)))
        }

        return (v, r, s);
    }

    // EIP-1271 support.
    // Since this is a smart contract and not an EOA fulfilling the order, this function will be called by seaport.
    function isValidSignature(
        bytes32 _hash,
        bytes memory _signature
    ) external view returns (bytes4) {
        (uint8 v, bytes32 r, bytes32 s) = splitSignature(_signature);
        address recoveredAddr = ecrecover(_hash, v, r, s);
        if (recoveredAddr == owner) {
            return 0x1626ba7e;
        } else {
            return 0x00000000;
        }
    }

    // A function utilized by the owner (the malicious lender) to be able to approve addresses to move tokens out of this contract.
    // that address can be the conduit, it can be himself etc
    function approveAddrToSpendToken(address _token, address _addr) external onlyOwner {
        IERC1155(_token).setApprovalForAll(_addr, true);
    }

    function _hijackERC1155Tokens() internal returns (bool) {
        SafeUtils.executeTransaction(
            address(safe),
            address(tokenToHijack),
            maliciousSafeTransaction,
            maliciousSafeTransactionSignature
        );

        return true;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
}
