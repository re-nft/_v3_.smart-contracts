// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.20;

import {ISafe} from "@src/interfaces/ISafe.sol";
import {Errors} from "@src/libraries/Errors.sol";

import {BaseTest} from "@test/BaseTest.sol";
import {SafeUtils} from "@test/utils/GnosisSafeUtils.sol";

contract DisableModuleOffset_PreventedExploits_Integration_Test is BaseTest {
    function test_DisableModule_Exploit() public {
        ///////////////////////////////////////////////////////////
        //                Admin whitelists a module              //
        ///////////////////////////////////////////////////////////

        // doesnt really matter what we enable as an extension,
        // so lets just use this address. Enable it with 0x11 so that it can
        // be both enabled and disabled.
        vm.prank(deployer.addr);
        admin.toggleWhitelistExtension(address(this), uint8(3));

        ///////////////////////////////////////////////////////////
        //                  Enable the module tx                 //
        ///////////////////////////////////////////////////////////

        // create safe transaction to enable the module
        bytes memory transaction = abi.encodeWithSelector(
            ISafe.enableModule.selector,
            address(this) // whitelisted extension
        );

        // sign the safe transaction
        bytes memory transactionSignature = SafeUtils.signTransaction(
            address(alice.safe),
            alice.privateKey,
            address(alice.safe),
            transaction
        );

        // Expect the transaction to execute successfully
        SafeUtils.executeTransaction(
            address(alice.safe),
            address(alice.safe),
            transaction,
            transactionSignature
        );

        // assert the module has been enabled
        assertEq(alice.safe.isModuleEnabled(address(this)), true);

        // asser the stop policy is still enabled
        assertEq(alice.safe.isModuleEnabled(address(stop)), true);

        ///////////////////////////////////////////////////////////
        //           Attempt to disable the module tx            //
        ///////////////////////////////////////////////////////////

        // create safe transaction to disable the stop policy
        bytes memory transactionToDisable = abi.encodeWithSelector(
            ISafe.disableModule.selector,
            address(this), // whitelisted extension -> prev module
            address(stop) // module
        );

        // sign the safe transaction
        bytes memory transactionSignatureToDisable = SafeUtils.signTransaction(
            address(alice.safe),
            alice.privateKey,
            address(alice.safe),
            transactionToDisable
        );

        // Expect the transaction to revert
        SafeUtils.executeTransactionWithError(
            address(alice.safe),
            address(alice.safe),
            transactionToDisable,
            transactionSignatureToDisable,
            abi.encodeWithSelector(
                Errors.GuardPolicy_UnauthorizedExtension.selector,
                address(stop)
            )
        );

        // Assert the stop policy is still enabled
        assertEq(alice.safe.isModuleEnabled(address(stop)), true);
    }
}
