// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.20;

import "forge-std/console.sol";
import {ISafe} from "@src/interfaces/ISafe.sol";
import {ZoneInterface} from "@src/interfaces/IZone.sol";
import {MockERC721} from "@test/mocks/tokens/standard/MockERC721.sol";
import {ECDSA} from "@openzeppelin-contracts/utils/cryptography/ECDSA.sol";
import {Seaport} from "@seaport-core/Seaport.sol";
import {IERC721Errors} from "@openzeppelin-contracts/interfaces/draft-IERC6093.sol";

import {
    Order,
    AdvancedOrder,
    FulfillmentComponent,
    Fulfillment,
    ItemType as SeaportItemType,
    CriteriaResolver,
    OfferItem,
    ConsiderationItem,
    OrderComponents,
    OrderType as SeaportOrderType
} from "@seaport-types/lib/ConsiderationStructs.sol";

import {ZoneParameters} from "@seaport-core/lib/rental/ConsiderationStructs.sol";

import {
    AdvancedOrderLib,
    ConsiderationItemLib,
    FulfillmentComponentLib,
    FulfillmentLib,
    OfferItemLib,
    OrderComponentsLib,
    OrderLib,
    OrderParametersLib,
    SeaportArrays,
    ZoneParametersLib
} from "@seaport-sol/SeaportSol.sol";

import {BaseTest} from "@test/BaseTest.sol";

import {SafeUtils} from "@test/utils/GnosisSafeUtils.sol";

import {RentalAssetUpdate, RentalId} from "@src/libraries/RentalStructs.sol";

import {RentalUtils} from "@src/libraries/RentalUtils.sol";

import {OrderType, OrderMetadata, RentalOrder} from "@src/libraries/RentalStructs.sol";

// Malicious zone contract that will execute an approval for the safe so that it can be
// transferred away after the rental has completed.
contract MaliciousZone {
    address public safe;
    address public token;
    bytes public transaction;
    bytes public transactionSignature;
    Seaport public seaport;

    constructor(
        address _safe,
        address _token,
        bytes memory _transaction,
        bytes memory _transactionSignature,
        Seaport _seaport
    ) {
        safe = _safe;
        token = _token;
        transaction = _transaction;
        transactionSignature = _transactionSignature;
        seaport = _seaport;
    }

    function validateOrder(
        ZoneParameters calldata
    ) external returns (bytes4 validOrderMagicValue) {
        // Execute the approval tx on the safe
        SafeUtils.executeTransaction(safe, token, transaction, transactionSignature);

        // Return the selector of validateOrder as the magic value.
        validOrderMagicValue = ZoneInterface.validateOrder.selector;
    }
}

// Demonstrates that the rented assets are not transferred to the rental safe until
// after they are registered with the protocol as rented assets.
contract PreapproveToBypassGuard_PreventedExploits_Integration_Test is BaseTest {
    using OfferItemLib for OfferItem;
    using ConsiderationItemLib for ConsiderationItem;
    using OrderComponentsLib for OrderComponents;
    using OrderLib for Order;
    using ECDSA for bytes32;

    MaliciousZone public maliciousZone;

    function test_PreapproveToBypassGuard_Exploit() public {
        // setup malicious zone so we can preapprove the NFT to Bob's address
        _setupPreapprove();

        // create alice's order
        _createAliceOrder();

        // create the exploit order
        _createExploitOrder();

        // prepare the orders for fulfillment
        (
            AdvancedOrder[] memory orders,
            FulfillmentComponent[][] memory offerComponents,
            FulfillmentComponent[][] memory considerationComponents
        ) = _prepOrdersToFulfill();

        // Expect fulfillment to revert because the asset will not be in the safe when the
        // `approve` call is made on the token contract.
        vm.expectRevert("GS013");
        vm.prank(bob.addr);
        seaport.fulfillAvailableAdvancedOrders(
            orders,
            new CriteriaResolver[](0),
            offerComponents,
            considerationComponents,
            conduitKey,
            address(create),
            2
        );
    }

    function _setupPreapprove() internal {
        // create safe transaction for preapproval
        bytes memory transaction = abi.encodeWithSignature(
            "approve(address,uint256)",
            bob.addr,
            0
        );
        // sign the safe transaction
        bytes memory transactionSignature = SafeUtils.signTransaction(
            address(bob.safe),
            bob.privateKey,
            address(erc721s[0]),
            transaction
        );

        // Deploy the malicious zone
        maliciousZone = new MaliciousZone(
            address(bob.safe),
            address(erc721s[0]),
            transaction,
            transactionSignature,
            seaport
        );
    }

    function _createAliceOrder() internal {
        // create a BASE order
        createOrder({
            offerer: alice,
            orderType: OrderType.BASE,
            erc721Offers: 1,
            erc1155Offers: 0,
            erc20Offers: 0,
            erc721Considerations: 0,
            erc1155Considerations: 0,
            erc20Considerations: 1
        });

        // finalize the order creation
        (
            Order memory order,
            bytes32 orderHash,
            OrderMetadata memory metadata
        ) = finalizeOrder();

        // create an order fulfillment
        createOrderFulfillment({
            _fulfiller: bob,
            order: order,
            orderHash: orderHash,
            metadata: metadata
        });
    }

    function _createExploitOrder() internal {
        // create a BASE order
        createOrder({
            offerer: carol,
            orderType: OrderType.BASE,
            erc721Offers: 1,
            erc1155Offers: 0,
            erc20Offers: 0,
            erc721Considerations: 0,
            erc1155Considerations: 0,
            erc20Considerations: 1
        });

        // add the malicious zone
        withZone(address(maliciousZone));

        // finalize the order creation
        (
            Order memory order,
            bytes32 orderHash,
            OrderMetadata memory metadata
        ) = finalizeOrder();

        // create an order fulfillment
        createOrderFulfillment({
            _fulfiller: bob,
            order: order,
            orderHash: orderHash,
            metadata: metadata
        });
    }

    function _prepOrdersToFulfill()
        internal
        view
        returns (
            AdvancedOrder[] memory orders,
            FulfillmentComponent[][] memory offerComponents,
            FulfillmentComponent[][] memory considerationComponents
        )
    {
        // create seaport orders and make sure the exploit order comes first
        orders = new AdvancedOrder[](2);
        orders[0] = ordersToFulfill[ordersToFulfill.length - 1].advancedOrder; // exploit
        orders[1] = ordersToFulfill[ordersToFulfill.length - 2].advancedOrder; // alice

        // build individual offer components array
        FulfillmentComponent[] memory offerComp0 = new FulfillmentComponent[](1);
        FulfillmentComponent[] memory offerComp1 = new FulfillmentComponent[](1);
        offerComp0[0] = FulfillmentComponent(0, 0);
        offerComp1[0] = FulfillmentComponent(1, 0);

        // build combined offer components array
        offerComponents = new FulfillmentComponent[][](2);
        offerComponents[0] = offerComp0;
        offerComponents[1] = offerComp1;

        // build individual consideration components array
        FulfillmentComponent[] memory considComp0 = new FulfillmentComponent[](1);
        FulfillmentComponent[] memory considComp1 = new FulfillmentComponent[](1);
        considComp0[0] = FulfillmentComponent(0, 0);
        considComp1[0] = FulfillmentComponent(1, 0);

        // build combined consideration components array
        considerationComponents = new FulfillmentComponent[][](2);
        considerationComponents[0] = considComp0;
        considerationComponents[1] = considComp1;
    }
}
