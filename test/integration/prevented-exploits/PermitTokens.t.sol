// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.20;

import {
    Order,
    OfferItem,
    ItemType as SeaportItemType
} from "@seaport-types/lib/ConsiderationStructs.sol";
import {OfferItemLib} from "@seaport-sol/SeaportSol.sol";
import {
    ERC721Burnable
} from "@openzeppelin-contracts/token/ERC721/extensions/ERC721Burnable.sol";
import {IERC721Errors} from "@openzeppelin-contracts/interfaces/draft-IERC6093.sol";

import {ISafe} from "@src/interfaces/ISafe.sol";
import {
    OrderType,
    OrderMetadata,
    RentalOrder,
    Hook
} from "@src/libraries/RentalStructs.sol";
import {Errors} from "@src/libraries/Errors.sol";
import {Actions} from "@src/Kernel.sol";

import {BaseTest} from "@test/BaseTest.sol";
import {SafeUtils} from "@test/utils/GnosisSafeUtils.sol";

contract PermitTokens_PreventedExploits_Integration_Test is BaseTest {
    function test_Success_Permit_NotWhitelisted() public {
        // mint the token directly to alice's safe
        erc721s[0].mint(address(alice.safe), 5);

        // assert that alice's safe owns the asset
        assertEq(erc721s[0].ownerOf(5), address(alice.safe));

        // remove the token from the whitelist, so that permit() can be
        // used for that asset
        vm.prank(deployer.addr);
        admin.toggleWhitelistAsset(address(erc721s[0]), false);

        // Create a digest that would allow bob to gain an approval
        // over token ID 0
        bytes memory digest = bytes.concat(
            keccak256(
                abi.encodePacked(
                    "\x19\x01",
                    erc721s[0].DOMAIN_SEPARATOR(),
                    keccak256(
                        abi.encode(
                            erc721s[0].PERMIT_TYPEHASH(),
                            bob.addr,
                            5,
                            erc721s[0].tokenIdNonces(5),
                            block.timestamp + 1000000
                        )
                    )
                )
            )
        );

        // Get the gnosis safe message hash for the digest
        bytes32 msgHash = fallbackPolicy.getMessageHashForSafe(alice.safe, digest);

        // owner of the safe will sign the message
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(alice.privateKey, msgHash);

        // Call permit() on the token
        erc721s[0].permit(bob.addr, 5, block.timestamp + 1000000, v, r, s);

        // Bob transfers the token out of the safe
        vm.prank(bob.addr);
        erc721s[0].transferFrom(address(alice.safe), bob.addr, 5);

        // assert that bob owns the asset
        assertEq(erc721s[0].ownerOf(5), bob.addr);
    }

    function test_Reverts_Permit_Whitelisted() public {
        // create a BASE order
        createOrder({
            offerer: alice,
            orderType: OrderType.BASE,
            erc721Offers: 1,
            erc1155Offers: 0,
            erc20Offers: 0,
            erc721Considerations: 0,
            erc1155Considerations: 0,
            erc20Considerations: 1
        });

        // finalize the order creation
        (
            Order memory order,
            bytes32 orderHash,
            OrderMetadata memory metadata
        ) = finalizeOrder();

        // create an order fulfillment
        createOrderFulfillment({
            _fulfiller: bob,
            order: order,
            orderHash: orderHash,
            metadata: metadata
        });

        // finalize the base order fulfillment
        finalizeBaseOrderFulfillment();

        // Create a digest that would allow carol to gain an approval
        // over token ID 0
        bytes memory digest = bytes.concat(
            keccak256(
                abi.encodePacked(
                    "\x19\x01",
                    erc721s[0].DOMAIN_SEPARATOR(),
                    keccak256(
                        abi.encode(
                            erc721s[0].PERMIT_TYPEHASH(),
                            carol.addr,
                            0,
                            erc721s[0].tokenIdNonces(0),
                            block.timestamp + 1000000
                        )
                    )
                )
            )
        );

        // Get the gnosis safe message hash for the digest
        bytes32 msgHash = fallbackPolicy.getMessageHashForSafe(bob.safe, digest);

        // owner of the safe will sign the message
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(bob.privateKey, msgHash);

        // Attempt to call permit() on the token
        vm.expectRevert(
            abi.encodeWithSelector(
                Errors.FallbackPolicy_UnauthorizedSender.selector,
                address(erc721s[0])
            )
        );
        erc721s[0].permit(carol.addr, 0, block.timestamp + 1000000, v, r, s);
    }

    function test_Success_FallbackCanBeDeactivated() public {
        // mint the token directly to alice's safe
        erc721s[0].mint(address(alice.safe), 5);

        // assert that alice's safe owns the asset
        assertEq(erc721s[0].ownerOf(5), address(alice.safe));

        // remove the token from the whitelist, so that permit() can be
        // used for that asset
        vm.prank(deployer.addr);
        admin.toggleWhitelistAsset(address(erc721s[0]), false);

        // Create a digest that would allow bob to gain an approval
        // over token ID 0
        bytes memory digest = bytes.concat(
            keccak256(
                abi.encodePacked(
                    "\x19\x01",
                    erc721s[0].DOMAIN_SEPARATOR(),
                    keccak256(
                        abi.encode(
                            erc721s[0].PERMIT_TYPEHASH(),
                            bob.addr,
                            5,
                            erc721s[0].tokenIdNonces(5),
                            block.timestamp + 1000000
                        )
                    )
                )
            )
        );

        // Get the gnosis safe message hash for the digest
        bytes32 msgHash = fallbackPolicy.getMessageHashForSafe(alice.safe, digest);

        // owner of the safe will sign the message
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(alice.privateKey, msgHash);

        // Disable the fallback policy
        vm.prank(deployer.addr);
        kernel.executeAction(Actions.DeactivatePolicy, address(fallbackPolicy));

        // Attempt to call permit() on the token
        vm.expectRevert(
            abi.encodeWithSelector(Errors.FallbackPolicy_Deactivated.selector)
        );
        erc721s[0].permit(bob.addr, 5, block.timestamp + 1000000, v, r, s);

        // Reactivate the guard policy
        vm.prank(deployer.addr);
        kernel.executeAction(Actions.ActivatePolicy, address(fallbackPolicy));

        // call permit() on the token
        erc721s[0].permit(bob.addr, 5, block.timestamp + 1000000, v, r, s);

        // Bob transfers the token out of the safe
        vm.prank(bob.addr);
        erc721s[0].transferFrom(address(alice.safe), bob.addr, 5);

        // assert that bob owns the asset
        assertEq(erc721s[0].ownerOf(5), bob.addr);
    }
}
