// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.20;

import {IERC721Errors} from "@openzeppelin-contracts/interfaces/draft-IERC6093.sol";
import {
    Order,
    AdvancedOrder,
    FulfillmentComponent,
    CriteriaResolver
} from "@seaport-types/lib/ConsiderationStructs.sol";
import {ZoneParameters} from "@seaport-core/lib/rental/ConsiderationStructs.sol";

import {ZoneInterface} from "@src/interfaces/IZone.sol";
import {OrderType, OrderMetadata, RentalOrder} from "@src/libraries/RentalStructs.sol";

import {BaseTest} from "@test/BaseTest.sol";
import {SafeUtils} from "@test/utils/GnosisSafeUtils.sol";
import {Errors} from "@src/libraries/Errors.sol";

// Demonstrates that the rental creation will always revert if there arent enough
// tokens to transfer in the order.
contract BypassInvariantChecks_PreventedExploits_Integration_Test is BaseTest {
    // Test that the order will fail if attempting to bypass the invariant checks by not
    // sending any tokens to the Create Policy.
    function test_BypassInvariantChecks_DontSendTokens_Exploit() public {
        // create a legit PAY order
        createOrder({
            offerer: alice,
            orderType: OrderType.PAY,
            erc721Offers: 1,
            erc1155Offers: 0,
            erc20Offers: 1,
            erc721Considerations: 0,
            erc1155Considerations: 0,
            erc20Considerations: 0
        });

        // finalize the pay order creation
        (
            Order memory payOrder,
            bytes32 payOrderHash,
            OrderMetadata memory payOrderMetadata
        ) = finalizeOrder();

        // create an order fulfillment for the pay order
        createOrderFulfillment({
            _fulfiller: alice,
            order: payOrder,
            orderHash: payOrderHash,
            metadata: payOrderMetadata
        });

        // create a malicious PAYEE order.
        createOrder({
            offerer: alice,
            orderType: OrderType.PAYEE,
            erc721Offers: 0,
            erc1155Offers: 0,
            erc20Offers: 0,
            erc721Considerations: 1,
            erc1155Considerations: 0,
            erc20Considerations: 1
        });

        // Set the ERC721 and ERC20 recipients as Alice herself
        orderToCreate.considerationItems[0].recipient = payable(alice.addr);
        orderToCreate.considerationItems[1].recipient = payable(alice.addr);

        // finalize the pay order creation
        (
            Order memory payeeOrder,
            bytes32 payeeOrderHash,
            OrderMetadata memory payeeOrderMetadata
        ) = finalizeOrder();

        // create an order fulfillment for the payee order
        createOrderFulfillment({
            _fulfiller: alice,
            order: payeeOrder,
            orderHash: payeeOrderHash,
            metadata: payeeOrderMetadata
        });

        // add an amendment to include the seaport fulfillment structs
        withLinkedPayAndPayeeOrders({payOrderIndex: 0, payeeOrderIndex: 1});

        // Expect revert because the create policy was never given any assets from alice.
        finalizePayOrderFulfillmentWithError(
            abi.encodeWithSelector(
                IERC721Errors.ERC721InsufficientApproval.selector,
                address(create),
                0
            )
        );
    }

    // Test that the order will fail if attempting to bypass the invariant checks by
    // first sending tokens to the Create Policy. This test demonstrates that while there
    // are sufficient tokens, the order will still be rejected because the offerer of an
    // order cannot also be the recipient of the consideration items in that order.
    function test_BypassInvariantChecks_SendTokensFirst_Exploit() public {
        // create a legit PAY order
        createOrder({
            offerer: alice,
            orderType: OrderType.PAY,
            erc721Offers: 1,
            erc1155Offers: 0,
            erc20Offers: 1,
            erc721Considerations: 0,
            erc1155Considerations: 0,
            erc20Considerations: 0
        });

        // finalize the pay order creation
        (
            Order memory payOrder,
            bytes32 payOrderHash,
            OrderMetadata memory payOrderMetadata
        ) = finalizeOrder();

        // create an order fulfillment for the pay order
        createOrderFulfillment({
            _fulfiller: alice,
            order: payOrder,
            orderHash: payOrderHash,
            metadata: payOrderMetadata
        });

        // create a malicious PAYEE order.
        createOrder({
            offerer: alice,
            orderType: OrderType.PAYEE,
            erc721Offers: 0,
            erc1155Offers: 0,
            erc20Offers: 0,
            erc721Considerations: 1,
            erc1155Considerations: 0,
            erc20Considerations: 1
        });

        // Set the ERC721 and ERC20 recipients as Alice herself
        orderToCreate.considerationItems[0].recipient = payable(alice.addr);
        orderToCreate.considerationItems[1].recipient = payable(alice.addr);

        // finalize the pay order creation
        (
            Order memory payeeOrder,
            bytes32 payeeOrderHash,
            OrderMetadata memory payeeOrderMetadata
        ) = finalizeOrder();

        // create an order fulfillment for the payee order
        createOrderFulfillment({
            _fulfiller: alice,
            order: payeeOrder,
            orderHash: payeeOrderHash,
            metadata: payeeOrderMetadata
        });

        // add an amendment to include the seaport fulfillment structs
        withLinkedPayAndPayeeOrders({payOrderIndex: 0, payeeOrderIndex: 1});

        // transfer the ERC721 directly to the create policy, and mint the ERC20 tokens
        // to the create policy as well.
        vm.prank(alice.addr);
        erc721s[0].approve(address(this), 0);
        erc721s[0].transferFrom(alice.addr, address(create), 0);
        erc20s[0].mint(address(create), 100);

        // Expect revert because the PAYEE order specified alice as the offerer and as
        // the recipient of the consideration items.
        finalizePayOrderFulfillmentWithError(
            abi.encodeWithSelector(Errors.CreatePolicy_OffererCannotBeRecipient.selector)
        );
    }
}
