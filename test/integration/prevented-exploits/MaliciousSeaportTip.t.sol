// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.20;

import {
    Order,
    OrderParameters,
    OfferItem,
    ConsiderationItem,
    FulfillmentComponent,
    Fulfillment,
    ItemType as SeaportItemType
} from "@seaport-types/lib/ConsiderationStructs.sol";
import {OfferItemLib, ConsiderationItemLib} from "@seaport-sol/SeaportSol.sol";

import {Errors} from "@src/libraries/Errors.sol";
import {
    OrderType,
    OrderMetadata,
    RentalOrder,
    Hook
} from "@src/libraries/RentalStructs.sol";

import {BaseTest} from "@test/BaseTest.sol";
import {SafeUtils} from "@test/utils/GnosisSafeUtils.sol";

import {MockAlwaysRevertERC20} from "@test/mocks/tokens/weird/MockAlwaysRevertERC20.sol";

// This mock ERC20 will succeed only on the first call to `transferFrom`
contract MockRevertAfterTransferERC20 is MockAlwaysRevertERC20 {
    bool public shouldRevert;

    function transferFrom(address, address, uint256) public override returns (bool) {
        require(!shouldRevert, "transferFrom() revert");

        // after the first call, dont allow transfers
        shouldRevert = true;

        return true;
    }
}

// Demonstrates that a fulfiller cannot add a malicious token to an order as
// a consideration tip that would prevent the order from ever being stopped.
contract MaliciousSeaportTip_PreventedExploits_Integration_Test is BaseTest {
    using ConsiderationItemLib for ConsiderationItem;

    function test_MaliciousSeaportTip_Exploit() public {
        // Deploy mock token
        MockRevertAfterTransferERC20 testToken = new MockRevertAfterTransferERC20();

        // mint the token to bob
        testToken.mint(alice.addr, 100);

        // approve the conduit to pull the token
        vm.prank(bob.addr);
        testToken.approve(address(conduit), type(uint256).max);

        // create a BASE order
        createOrder({
            offerer: alice,
            orderType: OrderType.BASE,
            erc721Offers: 1,
            erc1155Offers: 0,
            erc20Offers: 0,
            erc721Considerations: 0,
            erc1155Considerations: 0,
            erc20Considerations: 1
        });

        // finalize the order creation
        (
            Order memory order,
            bytes32 orderHash,
            OrderMetadata memory metadata
        ) = finalizeOrder();

        // create an order fulfillment
        createOrderFulfillment({
            _fulfiller: bob,
            order: order,
            orderHash: orderHash,
            metadata: metadata
        });

        // Add a consideration item tip to an order that has already been signed
        OrderParameters storage params = ordersToFulfill[0].advancedOrder.parameters;
        params.consideration.push(
            ConsiderationItemLib
                .empty()
                .withItemType(SeaportItemType.ERC20)
                .withToken(address(testToken))
                .withIdentifierOrCriteria(0)
                .withStartAmount(100)
                .withEndAmount(100)
                .withRecipient(address(create))
        );

        // Expect revert because the malicious tip token is not whitelisted as a payment
        finalizeBaseOrderFulfillmentWithError(
            abi.encodeWithSelector(
                Errors.CreatePolicy_PaymentNotWhitelisted.selector,
                address(testToken)
            )
        );
    }
}
